// lib/models/task_model.dart
import 'dart:async'; // Import for StreamSubscription

import 'package:hive/hive.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:dio/dio.dart';
import 'package:trans_video_x/services/post_service.dart';
import 'package:trans_video_x/services/task_repository.dart'; // Import the new repository
part 'task_model.g.dart'; // Generated by build_runner

@HiveType(typeId: 0) // Ensure typeId is unique for each HiveObject
class TaskModel extends HiveObject {
  @HiveField(0)
  late String id; // Using cosObjectKey

  @HiveField(1)
  late String name;

  @HiveField(2)
  late String path; // Original local path

  @HiveField(3)
  late int size;

  @HiveField(4)
  late String formattedSize;

  @HiveField(5)
  late String type;

  @HiveField(6)
  late String uploadTime; // Timestamp of when it was added/uploaded

  @HiveField(7)
  late String sourceLanguage;

  @HiveField(8)
  late String targetLanguage;

  @HiveField(9)
  late String status; // e.g., "Uploaded", "Processing", "Completed"

  @HiveField(10)
  late String cosObjectKey;

  @HiveField(11)
  String? downloadUrl;

  @HiveField(12)
  String? errorMessage;

  TaskModel({
    required this.id,
    required this.name,
    required this.path,
    required this.size,
    required this.formattedSize,
    required this.type,
    required this.uploadTime,
    required this.sourceLanguage,
    required this.targetLanguage,
    required this.status,
    required this.cosObjectKey,
    this.downloadUrl,
    this.errorMessage,
  });
}


// In your TaskViewModel or a dedicated Hive listening service

final taskBoxProvider = FutureProvider<Box<TaskModel>>((ref) async {
  // Ensure Hive is initialized and adapter registered in main.dart
  return await Hive.openBox<TaskModel>('tasksBox');
});

final taskPostProvider = Provider((ref) {
  final dio = Dio(); // Configure Dio as needed (interceptors, etc.)
  return PostService(dio);
});

final taskRepositoryProvider = Provider((ref) {
  return TaskRepository(ref.watch(taskPostProvider)); // Correctly instantiate TaskRepository
});


class TaskSyncViewModel extends StateNotifier<void> { // Or your preferred state type
  final Box<TaskModel> _taskBox;
  final TaskRepository _taskRepository;
  StreamSubscription? _hiveSubscription;

  TaskSyncViewModel(this._taskBox, this._taskRepository) : super(null) {
    _listenToHiveChanges();
  }

  void _listenToHiveChanges() {
    _hiveSubscription = _taskBox.watch().listen((event) {
      if (!event.deleted && event.value != null) {
        // event.value is the TaskModel that was added or updated
        // We are interested in new additions. You might need a flag in TaskModel
        // or a separate mechanism to identify truly "new" tasks vs updates
        // if tasks can be updated in Hive before being sent.

        // For simplicity, let's assume any non-deleted event with a value is a candidate
        // In a real scenario, you'd want to ensure you only send *new* tasks.
        // Perhaps tasks are initially saved with a status like 'pending_sync'
        // and updated to 'synced' after successful POST.

        final task = event.value as TaskModel;
        _sendTaskToBackend(task);
      }
    });
  }

  Future<void> _sendTaskToBackend(TaskModel task) async {
    try {
      await _taskRepository.postNewTask(task);
      print('Task ${task.id} successfully sent to backend.');
      // Optionally, update the task's status in Hive to 'synced' or similar
      // task.status = 'synced_to_backend';
      // await _taskBox.put(task.id, task);
    } catch (e) {
      print('Error sending task ${task.id} to backend: $e');
      // Handle error: retry logic, user notification, etc.
    }
  }

  @override
  void dispose() {
    _hiveSubscription?.cancel();
    super.dispose();
  }
}

// Provider for the ViewModel
final taskSyncViewModelProvider = StateNotifierProvider<TaskSyncViewModel, void>((ref) {
  final taskBox = ref.watch(taskBoxProvider).asData?.value;
  final taskRepository = ref.watch(taskRepositoryProvider);
  if (taskBox != null) {
    return TaskSyncViewModel(taskBox, taskRepository);
  }
  // Handle loading/error state for taskBoxProvider if necessary
  // For now, this will throw if taskBox isn't ready, which might be okay
  // if you ensure this provider is accessed only after taskBox is loaded.
  throw Exception("TaskBox not available");
});

// In your main.dart or a suitable place, you would "awaken" this provider
// if it's not directly used by a widget but needs to run in the background:
//
// void main() async {
//   // ... other initializations ...
//   final container = ProviderContainer();
//   container.read(taskBoxProvider); // Ensure box is opened
//   // Delay slightly or use a post-frame callback if taskSyncViewModelProvider
//   // depends on taskBoxProvider resolving.
//   await Future.delayed(Duration(milliseconds: 100)); // Simplistic delay
//   container.read(taskSyncViewModelProvider); // This starts the listening
//   runApp(UncontrolledProviderScope(container: container, child: MyApp()));
// }
